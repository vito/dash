{
  package ast
}

Dash <- _ e:Expr _ !. {
  return e, nil
}

Expr <- Let / Seq
Let <- s:Slot _ CommaToken? _ f:Expr? {
  decl := s.(SlotDecl)
  if f == nil {
    f = Self{}
  }
  if decl.Value != nil {
    return Let{
      Named: decl.Named,
      Type_: decl.Type_,
      Def_  : decl.Value,
      Body_: f.(Node),
    }, nil
  }
  if decl.Type_ != nil {
    return decl, nil
  }
  return nil, fmt.Errorf("impossible: no type or value")
}
Seq <- e:Form _ CommaToken? _ f:Expr? {
  if f == nil {
    return e, nil
  } else {
    return Seq{e.(Node), f.(Node)}, nil
  }
}

Form <- Infix / Term

Term <- Select / FunCall / List / Literal / Symbol

Slot <- ClassSlot                // cls A { a: Integer! = 1 } <- becomes a function that takes an empty record of args, can use other fields
      / TypeAndArgsAndBlockSlot  // pub a(foo: Boolean!): Integer! { 1 }
      / TypeAndBlockSlot         // pub a: Integer! { 1 }  <- becomes a function that takes an empty record of args, can use other fields
      / TypeAndValueSlot         // pub a: Integer! = 1    <- no longer required, default pre-initialized (don't need to worry about mutation)
      / ValueOnlySlot            // pub a = 1              <- as above, type inferred as Integer!

TypeAndValueSlot <- vis:Visibility _ name:Id _ ColonToken _ type_:Type _ "=" _ value:Form {
  return SlotDecl{
    Named: name.(string),
    Type_: type_.(Type),
    Value: value.(Node),
    Visibility: vis.(Visibility),
  }, nil
}

ValueOnlySlot <- vis:Visibility _ name:Id _ '=' _ val:Form {
  return SlotDecl{
    Named: name.(string),
    Value: val.(Node),
    Visibility: vis.(Visibility),
  }, nil
}

TypeAndBlockSlot <- vis:Visibility _ name:Id _ ColonToken _ type_:Type _ block:Block {
  blk := block.(Block)
  blk.Named = name.(string)
  return SlotDecl{
    Named: name.(string),
    Type_: hm.NewFnType(NewRecordType(""), type_.(Type)),
    Value: FunDecl{
      Named: name.(string),
      Ret: type_.(Type),
      Form: blk,
    },
    Visibility: vis.(Visibility),
  }, nil
}

TypeAndArgsAndBlockSlot <- vis:Visibility _ name:Id _ args:ArgTypes _ ColonToken _ type_:Type _ block:Block {
  blk := block.(Block)
  blk.Named = name.(string)
  return SlotDecl{
    Named: name.(string),
    Value: FunDecl{
      Named: name.(string),
      Args: args.([]SlotDecl),
      Ret: type_.(Type),
      Form: blk,
    },
    Visibility: vis.(Visibility),
  }, nil
}

ClassSlot <- ClsToken _ name:Id _ args:ArgTypes _ block:Block {
  blk := block.(Block)
  blk.Named = name.(string)
  blk.Form = Seq{blk.Form, Self{}}
  return SlotDecl{
    Named: name.(string),
    Value: FunDecl{
      Named: name.(string),
      Args: args.([]SlotDecl),
      Ret: NewRecordType(name.(string)),
      Form: blk,
    },
    Visibility: PrivateVisibility,
  }, nil
}
ClsToken <- "cls"

Visibility <- PubToken { return PublicVisibility, nil }
            / PvtToken { return PrivateVisibility, nil }
PubToken <- "pub"
PvtToken <- "pvt"

Id <- WordToken
WordToken <- [a-zA-Z0-9]+ {
  return string(c.text), nil
}
UpperId <- UpperToken
UpperToken <- [A-Z][a-zA-Z0-9]* {
  return string(c.text), nil
}

FunCall <- name:Term args:ArgValues {
  return FunCall{name.(Node), Record(args.([]Keyed[Node]))}, nil
}

ArgValues <- '(' args:KeyValue* ')' {
  return sliceOf[Keyed[Node]](args), nil
}
ArgTypes <- '(' args:ArgType* ')' {
  return sliceOf[SlotDecl](args), nil
}
ArgType <- ArgWithDefault / ArgWithBlockDefault / ArgWithType
ArgWithDefault <- name:Id _ ColonToken _ type_:Type _ "=" _ value:Form CommaToken? {
  return SlotDecl{
    Named: name.(string),
    Type_: type_.(Type),
    Value: value.(Node),
  }, nil
}
ArgWithBlockDefault <- name:Id _ ColonToken _ type_:Type _ block:Block CommaToken? {
  return SlotDecl{
    Named: name.(string),
    Type_: type_.(Type),
    Value: block.(Block),
  }, nil
}
ArgWithType <- name:Id _ ColonToken _ type_:Type CommaToken? {
  return SlotDecl{
    Named: name.(string),
    Type_: type_.(Type),
  }, nil
}

KeyValue <- key:WordToken ColonToken _ value:Form CommaToken? {
  return Keyed[Node]{key.(string), value.(Node)}, nil
}
ColonToken <- ':'

Type <- NonNull / NamedType / ListType / TypeVariable
NamedType <- name:UpperId {
  return NewRecordType(name.(string)), nil
}
ListType <- '[' inner:Type ']' {
  return ListType{inner.(Type)}, nil
}
NonNull <- inner:Type BangToken {
  return NonNullType{inner.(Type)}, nil
}
TypeVariable <- v:[a-z] {
  return hm.TypeVariable(v.(byte)), nil
}

BangToken <- '!'

CommaToken <- _ ',' _

Infix <- Default
Default <- left:Form _ InterroToken _ right:Term {
  return Default{left.(Node), right.(Node)}, nil
}
InterroToken <- '?'

Select <- left:Term _ DotToken _ name:Id {
  return Select{left.(Node), name.(string)}, nil
}
DotToken <- '.'

List <- '[' eles:(_ e:Form CommaToken? { return e, nil })* ']' {
  return List{sliceOf[Node](eles)}, nil
}

Block <- '{' _ e:Expr _ '}' {
  return Block{"", e.(Node)}, nil
}

Symbol <- name:Id {
  return Symbol{name.(string)}, nil
}

// Literals

Literal <- Integer / Boolean / String / Quoted / Null

Integer <- '0' / NonZeroDecimalDigit DecimalDigit* {
  value, err := strconv.ParseInt(string(c.text), 10, 64)
  if err != nil {
    return nil, err
  }
  return Integer(value), nil
}

Exponent <- 'e'i [+-]? DecimalDigit+

String <- '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
  c.text = bytes.Replace(c.text, []byte(`\/`), []byte(`/`), -1)
  value, err := strconv.Unquote(string(c.text))
  if err != nil {
    return nil, err
  }
  return String{value}, nil
}

EscapedChar <- [\x00-\x1f"\\]

EscapeSequence <- SingleCharEscape / UnicodeEscape

SingleCharEscape <- ["\\/bfnrt]

UnicodeEscape <- 'u' HexDigit HexDigit HexDigit HexDigit

DecimalDigit <- [0-9]

NonZeroDecimalDigit <- [1-9]

HexDigit <- [0-9a-f]i

Quoted <- '%' quoter:WordToken '{' raw:QuotedRawToken '}' {
  return Quoted{
    quoter.(string),
    raw.(string),
  }, nil
}
QuotedRawToken <- [^}]* {
  return string(c.text), nil
}

Boolean <- TrueToken { return Boolean(true), nil }
         / FalseToken { return Boolean(false), nil }
TrueToken <- "true"
FalseToken <- "false"

Null <- NullToken { return Null{}, nil }
NullToken <- "null"

_ "whitespace" <- [ \t\r\n]* CommentToken?

CommentToken <- '#' .*
